#!/bin/sh

trap 'exit 130' INT

# Parse --trace flag (must be first arg)
if [ "$1" = "--trace" ]; then
  TRACE=1
  shift
fi

if [ -z "$1" ]; then
  echo "Usage: ./scripts/run [--trace] <image> [args...]"
  echo "Run docker-lisp/<image> with optional tracing"
  exit 1
fi

d=${DEPTH:-0}

# Check image exists (only at top level)
if [ "$d" = "0" ] && ! docker image inspect "docker-lisp/$1" > /dev/null 2>&1; then
  echo "Image docker-lisp/$1 not found."
  echo ""
  echo "If this is a base or builtin, try:"
  echo "  ./scripts/build-base"
  echo "  ./scripts/build-builtins"
  echo ""
  echo "If this is your program, try:"
  echo "  ./scripts/build <path> [name]"
  exit 1
fi
indent=$(printf "%*s" $((d*2)) "" | sed "s/  /│ /g")

[ -n "$TRACE" ] && printf "\033[90m%s┌ %s\033[0m\n" "$indent" "$*" >&2

# Top level: compute host runtime path. Nested: use inherited RUNTIME_HOST.
if [ -z "$RUNTIME_HOST" ]; then
  RUNTIME_HOST="$(cd "$(dirname "$0")/.." && pwd)/runtime"
  mkdir -p "$RUNTIME_HOST"
fi

result=$(docker run --rm --init --platform=linux/amd64 \
  -v /var/run/docker.sock:/var/run/docker.sock \
  -v "$RUNTIME_HOST:/runtime" \
  -e RUNTIME_HOST="$RUNTIME_HOST" \
  -e SCOPE_PATH="${SCOPE_PATH:-/runtime}" \
  -e TRACE="$TRACE" \
  -e DEPTH=$((d+1)) \
  "docker-lisp/$@")

[ -n "$TRACE" ] && printf "\033[90m%s└ %s\033[0m\n" "$indent" "$result" >&2

echo "$result"

# Cleanup runtime at top level
if [ "$d" = "0" ]; then
  rm -rf "$RUNTIME_HOST"/* 2>/dev/null
  docker images -q 'docker-lisp/runtime/*' 2>/dev/null | xargs -r docker rmi -f >/dev/null 2>&1
fi

